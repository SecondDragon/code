
### 1. src 和 href 的区别

**src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。**  
（1）src  
src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；
在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。

```js
<script src =”js.js”></script>
```

当浏览器解析到该元素时，会暂停其他资源的下载和处理，
直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。

（2）href  
href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果在文档中添加

```js
<link href=”common.css” rel=”stylesheet”/>
```

那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。

### 2. 对 HTML 语义化的理解

**语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情**。

语义化的优点如下：

- 对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于 SEO。
  除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；

- 对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。

常见的语义化标签：

```html
<header></header>
头部

<nav></nav>
导航栏

<section></section>
区块（有语义化的div）

<main></main>
主要区域

<article></article>
主要内容

<aside></aside>
侧边栏

<footer></footer>
底部
```

3. DOCTYPE(⽂档类型) 的作⽤

DOCTYPE 是 HTML5 中一种标准通用标记语言的文档类型声明，**它的目的是告诉浏览器（解析器）应该以什么样（html 或 xhtml）的文档类型定义来解析文档**，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在 HTML ⽂档的第⼀⾏。

浏览器渲染页面的两种模式（可通过 document.compatMode 获取，比如，语雀官网的文档类型是 CSS1Compat）：

- **CSS1Compat：标准模式（Strick mode），默认模式**，浏览器使用 W3C 的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。

- **BackCompat：怪异模式(混杂模式)(Quick mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。
### 4. script 标签中 defer 和 async 的区别
**如果没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本**。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。

**defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析**，其区别如下：

- **执行顺序**：多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；

- **脚本是否并行执行**：
  > **async属性，表示后续文档的加载和执行与js脚本的加载和执行是并行进行的**，即异步执行；async 属性的js文件会在加载完成之后立即执行（多个js文件加载的话就是谁先加载成功谁先执行，因此会有顺序的不确定性，可能会造成bug）
  > ，如果此时后续文档尚未加载渲染完成，那么就会发生js阻塞html的解析

  > **defer属性**，加载**后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)**，js脚本需要等到文档所有元素解析完成之后才执行（完全不会影响文档的解析），多个js文件执行顺序与js文件开始加载的顺序相同，
  > 与js文件加载完成的顺序无关，DOMContentLoaded事件触发执行之前。

### 5. 常⽤的meta标签有哪些
meta 标签由 name 和 content 属性定义，用来描述网页文档的属性，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些name作为大家使用的共识，开发者还可以自定义name。

常用的meta标签：

（1）charset，用来描述HTML文档的编码类型：
```html
<meta charset="UTF-8" >
```
（2） keywords，页面关键词：
```html
<meta name="keywords" content="关键词" />

```
（3）description，页面描述：
```html
<meta name="description" content="页面描述内容" />
```

（4）refresh，页面重定向和刷新
```html
<meta http-equiv="refresh" content="0;url=" />
```

**（5）viewport，适配移动端，可以控制视口的大小和比例：**

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
```
其中，content 参数有以下几种：

- width viewport ：宽度(数值/device-width)
- height viewport ：高度(数值/device-height)
- initial-scale ：初始缩放比例
- maximum-scale ：最大缩放比例
- minimum-scale ：最小缩放比例
- user-scalable ：是否允许用户缩放(yes/no）

（6）搜索引擎索引方式：
```<meta name="robots" content="index,follow" />```

### 6. HTML5有哪些更新

### 7. img的srcset属性的作⽤？
响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：
```html
<img src="image-128.png" srcset="image-256.png 2x" />
```

使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。

按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：

```
<img src="image-128.png"
     srcset="image-128.png 128w, image-256.png 256w, image-512.png 512w"
     sizes="(max-width: 360px) 340px, 128px" />
```


其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。  
对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。

### 8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？


- 行内元素有：a b span `img input` select strong

- 块级元素有：`div` `ul` `ol li dl dt dd h1 h2 h3 h4 h5 h6 p`；

空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：

常见的有：**`<br>、<hr>、<img>、<input>、<link>、<meta>`**

### 9. 对 web worker 的理解


在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。

如何创建 web worker：

- 检测浏览器对于 web worker 的支持性

- 创建 web worker 文件（js，回传函数等）

- 创建 web worker 对象

## 前端面试题之CSS篇

### CSS选择器及其优先级


对于选择器的**优先级**：
- 标签选择器、伪元素选择器：1；
- 类选择器、伪类选择器、属性选择器：10；

- id 选择器：100；
- 内联样式：1000；

注意事项：

- !important声明的样式的优先级最高；
- 如果优先级相同，则最后出现的样式生效；
- 继承得到的样式的优先级最低；
- 通用选择器（*）、子选择器（>）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；
- 样式表的来源不同时，优先级顺序为：内



### 2. CSS中可继承与不可继承属性有哪些
#### 一、无继承性的属性

1. **display**：规定元素应该生成的框的类型
2. **文本属性**：
- vertical-align：垂直文本对齐
- text-decoration：规定添加到文本的装饰
- text-shadow：文本阴影效果
- white-space：空白符的处理
- unicode-bidi：设置文本的方向
3. **盒子模型的属性**：width、height、margin、border、padding
4. **背景属性**：background、background-color、background-image、background-repeat、background-position、background-attachment
5. **定位属性**：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index
6. **生成内容属性**：content、counter-reset、counter-increment
7. **轮廓样式属性**：outline-style、outline-width、outline-color、outline
8. **页面样式属性**：size、page-break-before、page-break-after
9. **声音样式属性**：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during

#### 二、有继承性的属性


1. **字体系列属性**
- font-family：字体系列
- font-weight：字体的粗细
- font-size：字体的大小
- font-style：字体的风格
2. **文本系列属性**
- text-indent：文本缩进
- text-align：文本水平对齐
- line-height：行高
- word-spacing：单词之间的间距
- letter-spacing：中文或者字母之间的间距
- text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）
- color：文本颜色
3. **元素可见性**
- visibility：控制元素显示隐藏
4. **列表布局属性**
- list-style：列表风格，包括list-style-type、list-style-image等
5. **光标属性**
- cursor：光标显示为何种形态



### 3. display的属性值及其作用

- **none**:元素不显示，并且会从文档流中移除。
- block:块类型。默认宽度为父元素宽度，可设置宽高，换行显示。
- inline:行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。
- inline-block: 默认宽度为内容宽度，可以设置宽高，同行显示。
- table: 此元素会作为块级表格来显示。

### 4. display的block、inline和inline-block的区别

（1）block：会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；  
（2）inline：元素不会独占一行，**设置width、height属性无效**。**但可以设置水平方向的margin和padding属性**，不能设置垂直方向的padding和margin；   
（3）inline-block：将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。


对于行内元素和块级元素，其特点如下：

（1）行内元素
- 设置宽高无效；
- 可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；
- 不会自动换行

（2）块级元素
- 可以设置宽高；
- 设置margin和padding都有效；
- 可以自动换行；
- 多个块状，默认排列从上到下。



### 5. 隐藏元素的方法有哪些

- **display**: none：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。
- **visibility**: hidden：元素在页面中仍占据空间，但是**不会响应绑定的监听事件**。
- **opacity**: 0：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且**能够响应元素绑定的监听事件**。
- **position**: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。
- **z-index**: 负值：来使其他元素遮盖住该元素，以此来实现隐藏。
- **clip/clip-path** ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，**但是不会响应绑定的监听事件**。
- **transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，**元素仍在页面中占据位置**，**但是不会响应绑定的监听事件**。

### 6. link和@import的区别

两者都是外部引用CSS的方式，它们的区别如下：
- link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
- link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
- link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
- **link支持使用Javascript控制DOM去改变样式**(存疑-不知道怎么用)；而@import不支持。

下面是例子
`link` 标签并不直接提供改变样式的能力，但是可以通过 JavaScript 改变 `link` 标签的 `href` 属性来实现使用不同的样式表去改变样式。以下是一个简单的例子：

HTML 代码：

```html
<!DOCTYPE html>
<html>
<head>
  <title>使用 JavaScript 控制样式表</title>
  <link rel="stylesheet" href="style1.css" id="styleSheet">
</head>
<body>
  <h1>Hello, World!</h1>

  <button onclick="changeStylesheet()">切换样式表</button>

  <script src="app.js"></script>
</body>
</html>
```

CSS 代码 (`style1.css`)：

```css
h1 {
  font-size: 48px;
  color: red;
}
```

另一个 CSS 文件 (`style2.css`)：

```css
h1 {
  font-size: 64px;
  color: blue;
}
```

JavaScript 代码 (`app.js`)：

```javascript
// 获取样式表 link 元素
const styleSheet = document.getElementById('styleSheet');

function changeStylesheet() {
  // 判断当前使用的样式表
  if (styleSheet.href.match('style1.css')) {
    // 切换到 style2.css
    styleSheet.href = 'style2.css';
  } else {
    // 切换到 style1.css
    styleSheet.href = 'style1.css';
  }
}
```

在上面的例子中，我们使用 `document.getElementById()` 方法获取了一个 ID 为 `styleSheet` 的 `link` 元素，并在 JavaScript 中将其保存为一个变量。然后，我们定义了一个名为 `changeStylesheet()` 的函数，在该函数中检查当前使用的样式表，并根据需要切换到另一个样式表。在这种情况下，我们只有两个样式表，但实际上您可以使用更多的样式表，并根据需要扩展该代码。

需要注意的是，该方法需要所有的样式表都有相同的选择器来改变同一个元素的样式，否则可能会出现不必要的复杂和混乱的代码。


### 7. transition和animation的区别

`transition` 和 `animation` 都是 CSS 中用于实现动画效果的属性，它们之间有以下主要的区别：

1. **作用对象不同**：`transition` 用于控制单个属性从一种状态过渡到另一种状态时的动画效果，而 `animation` 则可以实现更复杂的动画效果，包括多个关键帧和分阶段的动画。

2. **使用方式不同**：`transition` 被设计成一个简单易用的属性，只需在 CSS 规则的属性值中指定过渡时间和过渡方式即可，而 `animation` 对于每个动画都需要定义关键帧，以及动画的持续时间、循环次数等。

3. **控制时机不同**：`transition` 是在 CSS 属性发生变化时触发的，可以通过 `:hover` 、`:focus` 和 JavaScript 等触发。而 `animation` 则可以基于时间轴来控制动画的开始和结束，可以实现更加灵活和复杂的动画效果。

4. **兼容性不同**：虽然 `transition` 和 `animation` 都得到了大多数现代浏览器的支持，但是一些旧版本的浏览器可能不兼容其中的某些特性，需要在编码时进行兼容性处理。

总之，`transition` 和 `animation` 在实现动画效果的过程中，可以根据需要选择使用哪一个属性。如果只需要简单的属性过渡动画效果，可以使用 `transition`，而对于更为复杂的动画效果，则可以使用 `animation` 来实现。

下面是代码示例：

```html
<!-- transition 示例 -->
<div class="box"></div>

<style>
  .box {
    width: 100px;
    height: 100px;
    background-color: red;
    transition: width 1s;
  }
  
  .box:hover {
    width: 200px;
  }
</style>
```

上述代码中，当鼠标悬浮在 .box 元素上时，它的宽度会从 100px 平滑过渡到 200px。

在 CSS 动画中，我们可以使用多个关键帧来定义更加复杂的动画效果。以 rotate 为例，我们可以使用多个关键帧来控制元素在不同时间点上的旋转角度。

例如：

```css
/* 定义一个名为 rotateAnimation 的动画序列 */
@keyframes rotateAnimation {
  /* 第一帧，从初始状态到 30% 的状态 */
  0% {
    transform: rotate(0deg);
  }

  /* 第二帧，从 30% 到 60% 的状态 */
  30% {
    transform: rotate(180deg);
  }

  /* 第三帧，从 60% 到 90% 的状态 */
  60% {
    transform: rotate(360deg);
  }
  
  /* 第四帧，从 90% 到 100% 的状态 */
  90% {
    transform: rotate(270deg);
  }

  /* 最后一帧，完全变换的状态 */
  100% {
    transform: rotate(360deg);
  }
}

/* 将动画序列应用到元素上 */
.box {
  animation: rotateAnimation 2s ease-in-out infinite;
}
```

在这个例子中，我们定义了一个名为 rotateAnimation 的动画序列，并使用五个关键帧来控制旋转效果。第一个关键帧从初始状态到 30% 的状态，元素旋转角度为 0 度；第二个关键帧从 30% 到 60% 的状态，元素旋转角度为 180 度；第三个关键帧从 60% 到 90% 的状态，元素旋转角度为 360 度；第四个关键帧从 90% 到 100% 的状态，元素旋转角度为 270 度；最后一个关键帧表示完全变换的状态，元素旋转角度为 360 度。

最后，我们将动画序列应用到 .box 元素上，使用 animation 属性指定动画名称、持续时间、缓动函数和重复次数等参数。

注意：在使用多个关键帧的时候，每个关键帧之间的百分比值之和应该等于 100%，否则动画效果可能会出现卡顿或不自然的情况。同时也要注意控制每个关键帧之间的动画过渡效果，使得动画看起来更加平滑自然。

上述代码中，.box 元素会在 2 秒内无限循环地旋转，并且背景色从红色变成蓝色。这是通过定义了一个关键帧来实现的。





### 8. display:none与visibility:hidden的区别
display:none 与 visibility:hidden 都是用来隐藏元素的 CSS 属性，但它们之间有以下区别：

1. display: none 会将元素完全从页面中删除，该元素不占用任何空间，也不会影响其他元素的布局，而 visibility: hidden 只是将元素隐藏起来，但元素依然占用空间，仍然会影响其他元素的布局。

例如：

```html
<div style="height: 200px; background-color: red;"></div>
<div style="display: none; height: 100px; background-color: green;"></div>
<div style="visibility: hidden; height: 100px; background-color: blue;"></div>
<div style="height: 200px; background-color: yellow;"></div>
```

在这个例子中，第一个红色 div 占用了 200px 的高度，第二个绿色 div 使用了 display: none 被隐藏起来，不占用任何空间，第三个蓝色 div 使用了 visibility: hidden 被隐藏起来，仍然占用 100px 的高度空间，最后一个黄色 div 占用了 200px 的高度。

2. display: none 会阻止元素及其子元素的所有事件，无法点击、滚动等操作；visibility: hidden 则不会阻止任何事件，元素仍然可以被点击、滚动等操作。

3. display: none 会对屏幕阅读器和搜索引擎隐藏元素及其内容，被隐藏元素的内容不会被读取或收录；visibility: hidden 不会对屏幕阅读器和搜索引擎造成影响，被隐藏元素的内容仍然可以被读取或收录。

需要注意的是，display: none 会将该元素从页面中删除，如果使用 JavaScript 获取这个元素时，会获取到 null 或者 undefined 的值，而 visibility: hidden 只是将该元素隐藏了，可以使用 JavaScript 获取这个元素的属性值。
4. 修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘

### 伪元素和伪类的区别和作用？
伪元素和伪类都是 CSS 中的特殊选择器，它们的作用是帮助我们更加精确地选择元素和设置样式。

**伪元素（Pseudo-Element）** 是用来为元素的某个部分设置样式的，比如设置元素的第一行或第一字母等。伪元素的名称以 :: 开头，但为了兼容老版本的浏览器，也可以使用 : 符号来表示。

常见的伪元素包括：

- ::before：在元素内部的内容前插入一个元素。
- ::after：在元素内部的内容后插入一个元素。
- ::first-letter：选择元素的第一个字母。
- ::first-line：选择元素的第一行。

例如：

```css
p::first-letter {
  font-size: 2em;
  font-weight: bold;
}

p::first-line {
  color: blue;
  text-decoration: underline;
}
```

在这个例子中，我们使用伪元素选择器 ::first-letter 和 ::first-line 分别为 p 元素的第一个字母和第一行设置样式，显示出不同的效果。

**伪类（Pseudo-Class）** 是用来为元素的某个状态设置样式的，比如设置链接的鼠标悬停状态或选中状态等。伪类的名称以 : 开头。

常见的伪类包括：

- `:hover`：鼠标悬停在元素上时。
- `:active`：鼠标点击元素时。
- `:focus`：元素获得焦点时。
- `:visited`：访问过的链接。
- `:nth-child(n)`：选择元素的第 n 个子元素。

例如：

```css
a:hover {
  color: red;
  text-decoration: underline;
}

button:active {
  background-color: green;
}

input:focus {
  border: 2px solid blue;
}
```

在这个例子中，我们使用伪类选择器 :hover、:active 和 :focus 分别为链接、按钮和文本框设置样式，显示出不同的效果。

需要注意的是，在 CSS3 中，伪类和伪元素的语法规则发生了变化，伪元素使用双冒号（::）表示，而伪类使用单冒号（:）表示，但是为了兼容老版本的浏览器，还是可以使用单冒号来表示伪元素。

**总结**：伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。

10. 对requestAnimationframe的理解


requestAnimationFrame（简称 rAF）是一个浏览器 API，它提供了一种优化动画效果的方式。使用 requestAnimationFrame 可以让浏览器知道什么时候去更新动画，从而避免出现丢帧、掉帧的情况，让动画更加流畅自然。

requestAnimationFrame 的使用十分简单，只需要调用它，并传入一个回调函数即可。当浏览器准备好更新屏幕时，它会调用该函数，通常我们可以在该函数中更新动画的状态，然后再次调用 requestAnimationFrame 来请求下一帧动画。

例如：

```javascript
function animate() {
  // 更新动画状态
  // ...

  requestAnimationFrame(animate);
}
```

在这个例子中，我们定义了一个名叫 animate 的函数，并在函数中更新了动画状态。然后我们通过调用 requestAnimationFrame(animate) 来请求更新下一帧动画状态。

相比于使用 setTimeout 和 setInterval 来实现动画效果，使用 requestAnimationFrame 更加高效和稳定。因为 requestAnimationFrame 主要是根据浏览器的刷新率来绘制动画，保持了动画与浏览器的同步性，不会出现卡顿或掉帧现象。而 setTimeout 和 setInterval 却是基于固定时间间隔来执行代码，如果执行代码的时间过长或者浏览器的刷新率发生变化，容易导致动画效果不稳定。

需要注意的是，requestAnimationFrame 并不能完全取代 setTimeout 和 setInterval，因为 requestAnimationFrame 只能在浏览器环境下使用，并且在某些情况下可能会出现性能问题。因此，在实际开发中，我们需要结合业务场景和实际需求来选择最适合的方案。

好的，下面举一个使用 requestAnimationFrame 实现 DOM 元素平滑滚动的例子。

```javascript
function smoothScroll(target, duration) {
  const targetPosition = target.getBoundingClientRect().top; // 目标元素距离视口顶部的距离
  const startPosition = window.pageYOffset; // 当前窗口的滚动条位置
  const distance = targetPosition - startPosition; // 目标元素需要滚动的距离
  let startTime = null;

  function animation(currentTime) {
    if (startTime === null) { // 如果是第一次调用动画，则记录开始时间
      startTime = currentTime;
    }

    const timeElapsed = currentTime - startTime; // 经过的时间
    const run = ease(timeElapsed, startPosition, distance, duration); // 根据缓动函数计算当前的位置
    window.scrollTo(0, run); // 设置滚动条位置

    if (timeElapsed < duration) { // 如果动画未结束，则继续请求下一帧动画
      requestAnimationFrame(animation);
    }
  }

  function ease(t, b, c, d) { // 缓动函数，这里使用了简单的线性缓动函数
    return c * t / d + b;
  }

  requestAnimationFrame(animation);
}
```

在这个例子中，我们定义了一个名叫 smoothScroll 的函数，它接受两个参数：目标元素和持续时间。当调用该函数时，它会根据目标元素和持续时间来计算出需要滚动的距离，并通过 requestAnimationFrame 逐帧地调用 animation 函数来实现平滑滚动的效果。在 animation 函数中，我们使用缓动函数来计算当前位置，并设置滚动条的位置，如果动画未结束，则继续请求下一帧动画。

需要注意的是，这里使用了一个简单的线性缓动函数，但在实际开发中，我们可能需要根据实际需求选择更加合适的缓动函数来实现不同的效果。






### 11. 对盒模型的理解

- box-sizing: content-box表示标准盒模型（默认值）


- box-sizing: border-box表示IE盒模型（怪异盒模型）



### 12. 为什么有时候⽤translate来改变位置⽽不是定位？


`translate` 是 `transform` 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（`reflow`）或重绘（`repaint`）， 只会触发复合（compositions）。
⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。
因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。

### 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？
以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px & 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；

而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。

对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/578df630a6434db4860a5a06aac936fc~tplv-k3u1fbpfcp-watermark.image?)



当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。

还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:


```css
my-image { background: (low.png); }
@media only screen and (min-device-pixel-ratio: 1.5) {
  #my-image { background: (high.png); }
}
```

### CSS预处理器/后处理器是什么？为什么要使用它们？
预处理器，如：`less`，`sass`，`stylus`，用来预编译`sass`或者`less`，增加了css代码的**复用性**。层级，mixin， 变量，循环， 函数等对编写以及开发UI组件都极为方便。

后处理器， 如： postCss，通常是在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。

`css`预处理器为`css`增加一些编程特性，无需考虑浏览器的兼容问题，可以在CSS中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让css更加的简洁，增加适应性以及可读性，可维护性等。

其它css预处理器语言：Sass（Scss）, Less, Stylus, Turbine, Swithch css, CSS Cacheer, DT Css。

使用原因：
- 结构清晰， 便于扩展
- 可以很方便的屏蔽浏览器私有语法的差异
- 可以轻松实现多重继承
- 完美的兼容了CSS代码，可以应用到老项目中
### display:inline-block 什么时候会显示间隙？
- 有空格时会有间隙，可以删除空格解决；
- margin正值时，可以让margin使用负值解决
- 使用font-size时，可通过设置font-size:0、letter-spacing、word-spacing解决；

### 单行、多行文本溢出隐藏

单行文本溢出
```css
overflow: hidden;            // 溢出隐藏
text-overflow: ellipsis;      // 溢出用省略号显示
white-space: nowrap;         // 规定段落中的文本不进行换行
```

多行文本溢出
```css
overflow: hidden;            // 溢出隐藏
text-overflow: ellipsis;     // 溢出用省略号显示
display:-webkit-box;         // 作为弹性伸缩盒子模型显示。
-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列
-webkit-line-clamp:3;        // 显示的行数

```


### CSS 工程化是为了解决以下问题：
1. 宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？
2. 编码优化：怎样写出更好的 CSS？
3. 构建：如何处理我的 CSS，才能让它的打包结果最优？
4. 可维护性：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？

以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：
- 预处理器：`Less`、 `Sass` 等；
- 重要的工程化插件： `PostCss`；
- `Webpack` `loader` 等

基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：

**（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？**  
预处理器，其实就是 `CSS` 世界的“轮子”。预处理器支持我们写**一种类似 CSS、但实际并不是 CSS 的语言**，然后把它编译成 CSS 代码：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/270a34943df24c9388162e5e7f750fdc~tplv-k3u1fbpfcp-watermark.image?)

那为什么写 CSS 代码写得好好的，偏偏要转去写“类CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：  
1. **宏观设计上**：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；  
2. **编码优化上**：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；  
3. **可维护性上**：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。

这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：  
- 嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；
- 支持定义 `css` 变量；
- 提供计算函数；
- 允许对代码片段进行 `extend` 和 `mixin`；
- 支持循环语句的使用；
- 支持将 `CSS` 文件模块化，实现复用。


**（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？**  
`PostCss` 仍然是一个对 `CSS` 进行解析和处理的工具，它会对 CSS 做这样的事情：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb1141654adb45eebcbb02fc1faaebea~tplv-k3u1fbpfcp-watermark.image?)

它和预处理器的不同就在于，预处理器处理的是 类`CSS`，而 `PostCss` 处理的就是 `CSS` 本身。`Babel` 可以将高版本的 `JS` 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。

PostCss 在业务中的使用场景非常多：  
- 提高 `CSS` 代码的可读性：`PostCss` 其实可以做类似预处理器能做的工作；
- 当我们的 `CSS` 代码**需要适配低版本浏览器时**，`PostCss` 的 [Autoprefixer](https://github.com/postcss/autoprefixer) 插件可以帮助我们自动增加浏览器前缀；
- 允许我们编写面向未来的 `CSS`：`PostCss` 能够帮助我们编译 `CSS next` 代码； 

**（3）Webpack 能处理 CSS 吗？如何实现？**    
 Webpack 能处理 CSS 吗：  
- Webpack 在裸奔的状态下，是不能处理 CSS 的，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；
- Webpack 在 loader 的辅助下，是可以处理 CSS 的。

**如何用 Webpack 实现对 CSS 的处理：**  
- Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader  
- 注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：  
- css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；  
- style-loader：创建style标签，把 CSS 内容写入标签。

在实际使用中，**css-loader 的执行顺序一定要安排在 style-loader 的前面**。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。




### 如何判断元素是否到达可视区域 

**以图片显示为例：**
- window.innerHeight 是浏览器可视区的高度；
- document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动的过的距离；
- imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）；
- 内容达到显示区域的判定：img.offsetTop < window.innerHeight + document.body.scrollTop;




![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5b871bf2f2b45fdab9aa79fb747d74f~tplv-k3u1fbpfcp-watermark.image?)


























































